<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>JavaScript知识 | Yue技术文档网站</title><meta name="description" content="基于 VuePress v2 的技术文档">
    <link rel="preload" href="/assets/style-C2JCxPSn.css" as="style"><link rel="stylesheet" href="/assets/style-C2JCxPSn.css">
    <link rel="modulepreload" href="/assets/app-rlsOa5gl.js"><link rel="modulepreload" href="/assets/javascript.html-CiIKJVev.js">
    <link rel="prefetch" href="/assets/index.html-BHik5JY_.js" as="script"><link rel="prefetch" href="/assets/browser.html-D8APHM2Y.js" as="script"><link rel="prefetch" href="/assets/introduction.html-DFt6HHQw.js" as="script"><link rel="prefetch" href="/assets/vite.html-CLFj0avP.js" as="script"><link rel="prefetch" href="/assets/webpack.html-B6UXAgVw.js" as="script"><link rel="prefetch" href="/assets/api.html-nTvGlb4w.js" as="script"><link rel="prefetch" href="/assets/404.html-Cc_uUr84.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">Yue技术文档网站</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/guide/introduction.html" aria-label="指南"><!--[--><!--[--><!--]--><!--]-->指南<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/reference/api.html" aria-label="参考"><!--[--><!--[--><!--]--><!--]-->参考<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/guide/introduction.html" aria-label="指南"><!--[--><!--[--><!--]--><!--]-->指南<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/reference/api.html" aria-label="参考"><!--[--><!--[--><!--]--><!--]-->参考<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">指南 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/guide/introduction.html" aria-label="介绍"><!--[--><!--[--><!--]--><!--]-->介绍<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/guide/browser.html" aria-label="浏览器知识"><!--[--><!--[--><!--]--><!--]-->浏览器知识<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/guide/javascript.html" aria-label="JavaScript知识"><!--[--><!--[--><!--]--><!--]-->JavaScript知识<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/guide/webpack.html" aria-label="Webpack知识"><!--[--><!--[--><!--]--><!--]-->Webpack知识<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/guide/vite.html" aria-label="Vite知识"><!--[--><!--[--><!--]--><!--]-->Vite知识<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><h1 id="javascript知识" tabindex="-1"><a class="header-anchor" href="#javascript知识"><span>JavaScript知识</span></a></h1><h2 id="js高级" tabindex="-1"><a class="header-anchor" href="#js高级"><span>js高级</span></a></h2><h3 id="一、基础总结深入" tabindex="-1"><a class="header-anchor" href="#一、基础总结深入"><span>一、基础总结深入</span></a></h3><h4 id="_1、数据类型" tabindex="-1"><a class="header-anchor" href="#_1、数据类型"><span>1、数据类型</span></a></h4><ol><li>基本数据类型：number、string、boolean、null、undefined、symbol、bigint</li><li>引用数据类型：object、array、function</li></ol><h4 id="_2、数据、变量、内存" tabindex="-1"><a class="header-anchor" href="#_2、数据、变量、内存"><span>2、数据、变量、内存</span></a></h4><h4 id="_3、对象" tabindex="-1"><a class="header-anchor" href="#_3、对象"><span>3、对象</span></a></h4><h4 id="_4、函数" tabindex="-1"><a class="header-anchor" href="#_4、函数"><span>4、函数</span></a></h4><h4 id="_5、回调函数" tabindex="-1"><a class="header-anchor" href="#_5、回调函数"><span>5、回调函数</span></a></h4><h4 id="_6、iifel立即执行函数" tabindex="-1"><a class="header-anchor" href="#_6、iifel立即执行函数"><span>6、IIFEL立即执行函数</span></a></h4><ol><li>作用：隐藏实现，不会污染全局命名空间，用它来编码js模块</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  (function(){</span>
<span class="line">    var a = 1</span>
<span class="line">    console.log(a)</span>
<span class="line">  })()</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7、函数中的this" tabindex="-1"><a class="header-anchor" href="#_7、函数中的this"><span>7、函数中的this</span></a></h4><ol><li>this是什么：所有函数内部都有一个变量this，它的值是调用函数的当前对象</li><li>如何确定this的值： <ul><li>test()：this指向window</li><li>obj.test()：this指向obj</li><li>new test()：this指向新创建的对象</li><li>test.call(obj)：this指向obj</li></ul></li></ol><h3 id="二、函数高级" tabindex="-1"><a class="header-anchor" href="#二、函数高级"><span>二、函数高级</span></a></h3><h4 id="_1、原型与原型链" tabindex="-1"><a class="header-anchor" href="#_1、原型与原型链"><span>1、原型与原型链</span></a></h4><ol><li>函数的prototype属性</li></ol><ul><li>每个函数都有一个prototype属性，它默认指向一个Object空对象（原型对象）</li><li>原型对象中有一个属性constructor，它指向函数对象</li></ul><ol start="2"><li>显式原型和隐式原型</li></ol><ul><li>每个函数function都有一个prototype，即显式原型（属性）</li><li>每个实例对象都有一个__proto__，可称为隐式原型（属性）</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li><li>总结： <ul><li>函数的prototype属性：在定义函数时自动添加的，默认值是一个空Object对象</li><li>对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li><li>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）</li></ul></li></ul><ol start="3"><li>原型链</li></ol><ul><li>访问一个对象的属性时，先在自身属性中查找，找到返回</li><li>没有找到，再沿着__proto__这条链向上查找，找到返回</li><li>如果最终没找到，返回undefined</li><li>别名：隐式原型链</li><li>作用：查找对象的属性（方法）</li><li>补充知识点： <ul><li>函数的显示原型指向的对象默认是空的Object实例对象（但Object函数不满足）</li><li>所有函数都是Function的实例（包括Function，Function是其自身的实例）</li><li>Object的原型对象是原型链的尽头:Object.prototype.__ proto __ === null</li></ul></li></ul><ol start="4"><li>原型链——属性问题</li></ol><ul><li>读取对象的属性值时：会自动到原型链中查找</li><li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，则直接添加此属性并设置其值</li><li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</li></ul><ol start="5"><li>探索instanceof</li></ol><ul><li>instanceof是如何判断的？ <ul><li>表达式：A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false</li></ul></li><li>Function是通过new自己产生的实例</li><li>Object是通过new Function产生的实例</li></ul><h4 id="_2、执行上下文与执行上下文栈" tabindex="-1"><a class="header-anchor" href="#_2、执行上下文与执行上下文栈"><span>2、执行上下文与执行上下文栈</span></a></h4><ol><li>变量提升与函数提升</li></ol><ul><li>变量声明提升：通过var定义（声明）的变量，在定义语句之前就可以访问到，值为undefined</li><li>函数声明提升：通过function声明的函数，在之前就可以直接调用，值为函数体</li></ul><ol start="2"><li>执行上下文</li></ol><ul><li>全局执行上下文：在执行全局代码前将window确定为全局执行上下文</li><li>对全局数据进行预处理 <ul><li>var定义的全局变量：undefined，添加为window属性</li><li>function声明的全局函数：赋值（fun），添加为window的方法</li><li>this：赋值（window）</li></ul></li><li>开始执行全局代码</li></ul><ol start="3"><li>函数执行上下文</li></ol><ul><li>在调用函数，准备执行函数体之前，创建对应的函数执行上下文(虚拟的，存在于栈中)</li><li>对局部数据进行预处理 <ul><li>形参变量：赋值（实参），添加为执行上下文的属性</li><li>arguments：赋值（实参列表），添加为执行上下文的属性</li><li>var定义的局部变量：undefined，添加为执行上下文的属性</li><li>函数声明：赋值（fun），添加为执行上下文的方法</li><li>var定义的局部变量：undefined，添加为执行上下文的属性</li><li>function声明的函数：赋值（fun），添加为执行上下文的方法</li><li>this：赋值（调用函数的对象）</li></ul></li><li>开始执行函数体代码</li></ul><ol start="4"><li>执行上下文栈</li></ol><ul><li>在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li><li>在函数执行上下文创建后，将其添加到栈中（压栈）</li><li>在当前函数执行完后，将栈顶的对象移除（出栈）</li><li>当所有的代码执行完毕后，栈中只剩下window</li><li><h4 id="_3、作用域与作用域链" tabindex="-1"><a class="header-anchor" href="#_3、作用域与作用域链"><span>3、作用域与作用域链</span></a></h4><ol><li>作用域与执行上下文的区别</li></ol><ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</li><li>全局执行上下文环境是在全局代码执行前创建，而执行上下文环境是在函数执行时创建</li><li>函数执行上下文环境是在调用函数时，函数体代码执行之前创建</li></ul><h4 id="_4、闭包" tabindex="-1"><a class="header-anchor" href="#_4、闭包"><span>4、闭包</span></a></h4><ol><li>闭包理解</li></ol><ul><li>如何产生闭包？ <ul><li>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量(函数)时，就产生了闭包</li></ul></li><li>闭包是什么？ <ul><li>理解一：闭包是嵌套的内部函数（绝大部分人）</li><li>理解二：包含被引用变量（函数）的对象（极少数人）</li></ul></li><li>产生闭包的条件？ <ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据（变量/函数）</li></ul></li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  function fn1(){</span>
<span class="line">      var a = 2;</span>
<span class="line">      var b = &#39;abc&#39;;</span>
<span class="line">      function fn2(){ //执行函数定义就会产生闭包（不用调用内部函数）</span>
<span class="line">          console.log(a);</span>
<span class="line">      }</span>
<span class="line">  }</span>
<span class="line">  fn1();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>常见的闭包</li></ol><ul><li>将函数作为另一个函数的返回值</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function fn1() {</span>
<span class="line">    var a = 2</span>
<span class="line">    function fn2() {</span>
<span class="line">        a++</span>
<span class="line">        console.log(a)</span>
<span class="line">    }</span>
<span class="line">    return fn2</span>
<span class="line">}</span>
<span class="line">var f = fn1()</span>
<span class="line">f() // 3</span>
<span class="line">f() // 4</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>将函数作为实参传递给另一个函数调用</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  function showDelay(msg,time){</span>
<span class="line">      setTimeout(function(){</span>
<span class="line">          console.log(msg);</span>
<span class="line">      },time);</span>
<span class="line">  }</span>
<span class="line">  showDelay(&#39;hello world&#39;,2000);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>闭包的作用</li></ol><ul><li>使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</li><li>让函数外部可以操作（读写）到函数内部的局部变量（变量私有化）</li><li>问题：</li><li>函数执行完后，函数内部声明的局部变量是否还存在？答：一般是不存在，存在于闭包中的变量才可能存在</li><li>在函数外部能直接访问函数内部的局部变量吗？答：不能，但我们可以通过闭包让外部操作它</li></ul><ol start="4"><li>闭包的生命周期</li></ol><ul><li>产生：在嵌套内部函数定义执行完时就产生了（不是在调用时）</li><li>死亡：在嵌套的内部函数成为垃圾对象时</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  function fn1() {</span>
<span class="line">      //此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span>
<span class="line">      var a = 2</span>
<span class="line">      function fn2() {</span>
<span class="line">          a++</span>
<span class="line">          console.log(a)</span>
<span class="line">      }</span>
<span class="line">      return fn2</span>
<span class="line">  }</span>
<span class="line">  var f = fn1()</span>
<span class="line">  f() //3</span>
<span class="line">  f() //4</span>
<span class="line">  f = null //闭包死亡（包含闭包的函数对象成为垃圾对象）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>闭包的应用</li></ol><ul><li>定义JS模块 <ul><li>具有特定功能的js文件</li><li>将所有的数据和功能都封装在一个函数内部（私有的）</li><li>只向外暴露一个包含n个方法的对象或函数</li><li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul></li></ul><ol start="6"><li>闭包的缺点及解决</li></ol><ul><li>缺点：函数执行完后，函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄漏</li><li>解决：及时释放，将不需要的变量置为null</li><li>内存溢出： <ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时，就会发生内存溢出</li></ul></li><li>内存泄漏 <ul><li>占用的内存没有及时释放</li><li>内存泄漏积累多了就容易导致内存溢出</li><li>常见的内存泄漏： <ul><li>意外的全局变量</li><li>没有被清理的计时器或回调函数</li><li>闭包</li></ul></li></ul></li></ul><h3 id="三、面向对象高级" tabindex="-1"><a class="header-anchor" href="#三、面向对象高级"><span>三、面向对象高级</span></a></h3><ol><li>对象创建模式</li></ol><ul><li>方式一：Object构造函数模式 <ul><li>套路：先创建空Object对象，再动态添加属性/方法</li><li>适用场景：起始时不确定对象内部数据</li><li>问题：语句太多</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var p = new Object()</span>
<span class="line">p.name = &quot;John&quot;</span>
<span class="line">p.age = 30</span>
<span class="line">p.setName = function(name) {</span>
<span class="line">    this.name = name</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式二：对象字面量{} <ul><li>套路：使用{}创建对象，同时指定属性/方法</li><li>适用场景：起始时对象内部数据是确定的</li><li>问题：如果创建多个对象，会有重复代码</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  var p ={</span>
<span class="line">      name:&quot;p&quot;,</span>
<span class="line">      age:12,</span>
<span class="line">      setName:function(name){</span>
<span class="line">          this.name=name;</span>
<span class="line">      }</span>
<span class="line">  }</span>
<span class="line">  p.setName(&quot;p2&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式三：工厂模式 <ul><li>套路：通过工厂函数动态创建对象并返回</li><li>适用场景：需要创建多个对象</li><li>对象没有一个具体的类型，都是Object类型</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  function createPerson(name, age) {</span>
<span class="line">      var obj = {</span>
<span class="line">          name: name,</span>
<span class="line">          age: age,</span>
<span class="line">          setName:function (name) {</span>
<span class="line">              this.name = name;</span>
<span class="line">          }</span>
<span class="line">      }</span>
<span class="line">      return obj;</span>
<span class="line">  }</span>
<span class="line">  var p1 = createPerson(&#39;张三&#39;, 20);</span>
<span class="line">  var p2 = createPerson(&#39;李四&#39;, 30);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式四：自定义构造函数模式 <ul><li>套路：自定义构造函数，通过new创建对象实例</li><li>适用场景：需要创建多个类型确定的对象</li><li>问题：每个对象都有相同的数据（方法），浪费内存</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  function Person(name,age){</span>
<span class="line">      this.name=name;</span>
<span class="line">      this.age=age;</span>
<span class="line">      this.setName=function(name){</span>
<span class="line">          this.name=name;</span>
<span class="line">      }</span>
<span class="line">  }</span>
<span class="line">  var p1=new Person(&quot;张三&quot;,18);</span>
<span class="line">  p1.setName(&quot;李四&quot;);</span>
<span class="line">  console.log(p1 instanceof Person);//true</span>
<span class="line"></span>
<span class="line">  function Student(name,price){</span>
<span class="line">      this.name=name;</span>
<span class="line">      this.price=price;</span>
<span class="line">  }</span>
<span class="line">  var s = new Student(&quot;张三&quot;,1000);</span>
<span class="line">  console.log(s instanceof Student);//true</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式五：构造函数+原型的组合模式 <ul><li>套路：自定义构造函数，属性定义在构造函数中，方法定义在原型对象中</li><li>适用场景：需要创建多个类型确定的对象</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function Person(name, age) {</span>
<span class="line">    this.name = name;</span>
<span class="line">    this.age = age;</span>
<span class="line">}</span>
<span class="line">Person.prototype.setName = function(name) {</span>
<span class="line">    this.name = name;</span>
<span class="line">}</span>
<span class="line">var p1 = new Person(&quot;张三&quot;,18);</span>
<span class="line">var p2 = new Person(&quot;李四&quot;,20);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>继承模式</li></ol><ul><li>方式一：原型链继承 <ul><li>定义父类型构造函数，给父类型的原型添加方法。定义子类型的构造函数，创建父类型的对象赋值给子类型的原型。将子类型原型的构造属性设置为子类型，给子类型原型添加方法。创建子类型的对象：可以调用父类型的方法。（关键：子类型的原型为父类型的一个实例对象）</li></ul></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function Supper(){</span>
<span class="line">    this.supProp = &#39;Supper property&#39;</span>
<span class="line">}</span>
<span class="line">Supper.prototype.showSubpperProp = function(){</span>
<span class="line">    console.log(this.supProp)</span>
<span class="line">}</span>
<span class="line">//子类型</span>
<span class="line">function Sub(){</span>
<span class="line">    this.subProp = &#39;Sub property&#39;</span>
<span class="line">}</span>
<span class="line">Sub.prototype = new Supper()</span>
<span class="line">Sub.prototype.showSubProp = function(){</span>
<span class="line">    console.log(this.subProp)</span>
<span class="line">}</span>
<span class="line">var sub = new Sub()</span>
<span class="line">sub.showSubpperProp()</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>方式二：借用构造函数继承</li><li>方式三：组合继承</li></ul><h3 id="四、线程机制与事件机制" tabindex="-1"><a class="header-anchor" href="#四、线程机制与事件机制"><span>四、线程机制与事件机制</span></a></h3><ol><li>进程与线程</li><li>浏览器内核</li><li>定时器</li></ol><ul><li>定时器真是定时执行的吗？ <ul><li>定时器并不能保证真正定时执行</li><li>一般会延迟一丁点（可以接受），也有可能延迟很长时间（不能接受）</li></ul></li><li>定时器回调函数是在分线程执行的吗？ <ul><li>在主线程执行的，js是单线程的</li></ul></li><li>定时器是如何实现的？ <ul><li>事件循环模型</li></ul></li></ul><ol start="4"><li>js是单线程的</li></ol><ul><li>如何证明js执行时单线程的？ <ul><li>setTimeout()的回调函数是在主线程执行的</li><li>定时器回调函数只有在运行栈中的代码执行完毕后才有可能执行</li><li>为什么js要用单线程模式，而不用多线程模式？ <ul><li>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</li></ul></li></ul></li></ul><ol start="5"><li>事件循环模型</li><li>Web Workers测试</li><li>Web Workers应用</li></ol><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h2><h3 id="一、使用-const-定义函数和直接用-function-声明有什么区别" tabindex="-1"><a class="header-anchor" href="#一、使用-const-定义函数和直接用-function-声明有什么区别"><span>一、使用 const 定义函数和直接用 function 声明有什么区别？</span></a></h3><ol><li>作用域提升</li></ol><ul><li>function声明： 函数声明是 <strong>会被提升（hoisted）</strong> 的。这意味着你可以在声明函数之前调用它，编译器会在执行代码之前把函数声明移动到作用域的顶部。</li><li>const声明：使用const或者let声明的函数不会提升。实际上，这种函数声明会被视为变量声明，而变量声明只会被“声明”提升，但赋值部分并不会提升。因此，在赋值完成之前使用这个函数会导致ReferenceError。</li></ul><ol start="2"><li>是否可以重新赋值</li></ol><ul><li>function声明： 使用function声明的函数可以在同一作用域内被重新定义。虽然这种做法并不常见，但在一些特定情况下可能发生。</li><li>const声明： 使用const声明的函数是不可重新赋值的。你不能再次给它赋值，否则会引发TypeError</li></ul><ol start="3"><li>箭头函数 vs 传统函数</li></ol><ul><li>箭头函数的this绑定： 箭头函数中的this是词法绑定的，意思是this取决于函数定义时所在的上下文环境，而不是调用时。</li></ul><ol start="4"><li>代码风格和意图</li></ol><ul><li>function声明： 函数声明通常用于定义独立的函数逻辑。它清晰地表明这是一个函数，而不是变量赋值的结果。</li><li>const声明： 使用const声明函数通常表明这是一个不能重新赋值的函数表达式，在某些情况下，这可以防止意外重写变量。此外，const还能更明确地告诉读者这个函数不会被重新赋值，从而提高代码的可读性和安全性。</li></ul><h3 id="二、说说你对高阶函数的理解" tabindex="-1"><a class="header-anchor" href="#二、说说你对高阶函数的理解"><span>二、说说你对高阶函数的理解</span></a></h3><p>高阶函数是指满足以下任意一个条件的函数：</p><ul><li>能接收函数作为参数：可以把其他函数当作参数传递给它。</li><li>能够返回函数：函数的返回值可以是另一个函数。</li></ul><p>JavaScript 的数组原型上有很多实用的高阶函数，例如：map、filter、reduce、sort 等。这些函数都接收一个函数作为参数，并返回一个新数组。</p><p>您可以通过左侧边栏导航浏览不同章节的内容，或使用右上角的搜索框查找特定主题。</p><h3 id="三、js中本地对象、内置对象、宿主对象分别是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#三、js中本地对象、内置对象、宿主对象分别是什么-有什么区别"><span>三、JS中本地对象、内置对象、宿主对象分别是什么，有什么区别？</span></a></h3><ol><li>本地对象：Object、Function、Boolean、Symbol、Array、Map、Set、WeakMap、WeakSet、Error、TypeError、SyntaxError</li><li>内置对象：除了本地对象之外，JavaScript 还有一些内置对象，它们是全局对象的一部分，但不是本地对象。这些对象包括：parseInt()、eval()、isNaN()、Infinity、NaN、undefined、Math、JSON、Reflect、Intl</li><li>宿主对象：宿主对象是由运行环境提供的对象，例如浏览器中的window对象、Node.js中的global对象。这些对象提供了与运行环境交互的接口，例如访问DOM、执行网络请求等。</li></ol><h3 id="四、-get-请求的参数是否能够使用数组" tabindex="-1"><a class="header-anchor" href="#四、-get-请求的参数是否能够使用数组"><span>四、 get 请求的参数是否能够使用数组？</span></a></h3><p>在 HTTP 的 GET 请求中，参数可以使用数组形式。GET 请求的参数通常通过 URL 的查询字符串（Query String）传递，格式为 ?key=value&amp;key=value。这种情况下，同一个参数名重复出现时，大多数后端框架会自动将其解析为数组。</p><h3 id="五、-数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少" tabindex="-1"><a class="header-anchor" href="#五、-数组里面有10万个数据-取第一个元素和第10万个元素的时间相差多少"><span>五、 数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少？</span></a></h3><p>在 JavaScript 中，数组是基于连续内存空间实现的动态数据结构，其索引访问的时间复杂度为 O(1)。因此，理论上访问第一个元素和第 10 万个元素的时间是相同的。组的每个元素在内存中是连续存储的，元素地址可通过公式计算：address = base_address + index * element_size</p><h3 id="六、-javascript-对象的底层数据结构是什么" tabindex="-1"><a class="header-anchor" href="#六、-javascript-对象的底层数据结构是什么"><span>六、 JavaScript 对象的底层数据结构是什么？</span></a></h3><h3 id="七、-javascript-中的变量在内存中的具体存储形式是什么" tabindex="-1"><a class="header-anchor" href="#七、-javascript-中的变量在内存中的具体存储形式是什么"><span>七、 JavaScript 中的变量在内存中的具体存储形式是什么？</span></a></h3><h3 id="八、-一直在-window-上面挂内容-数据-方法等等-是否有什么风险" tabindex="-1"><a class="header-anchor" href="#八、-一直在-window-上面挂内容-数据-方法等等-是否有什么风险"><span>八、 一直在 window 上面挂内容（数据，方法等等），是否有什么风险？</span></a></h3><ol><li>命名空间污染与全局变量冲突：在全局作用域中定义过多的变量和函数会导致命名空间污染，可能会与其他库或框架的变量或函数发生冲突。</li><li>内存泄漏：在全局作用域中定义过多的变量和函数可能会导致内存泄漏。例如，如果全局变量引用了不再需要的对象，垃圾回收器将无法回收这些对象，导致内存泄漏。内存占用持续增长，导致页面卡顿甚至崩溃。</li><li>安全漏洞</li></ol><ul><li>内存占用持续增长，导致页面卡顿甚至崩溃。</li><li>原型链污染：恶意代码可能修改 window 的原型（如window.Object.prototype），影响所有对象。</li></ul><h3 id="九、-普通函数动态参数-和-箭头函数的动态参数有什么区别" tabindex="-1"><a class="header-anchor" href="#九、-普通函数动态参数-和-箭头函数的动态参数有什么区别"><span>九、 普通函数动态参数 和 箭头函数的动态参数有什么区别？</span></a></h3><p>在 JavaScript 中，普通函数和箭头函数处理动态参数（不定数量的参数）的方式存在显著差异，主要体现在 arguments 对象、剩余参数语法和上下文绑定上。以下是具体对比：</p><ol><li>arguments 对象的差异</li></ol><ul><li>普通函数：拥有内置的 arguments 对象，它是一个类数组对象，包含了函数调用时传递的所有参数。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function sum() {</span>
<span class="line">    let total = 0;</span>
<span class="line">    for (let i = 0; i &lt; arguments.length; i++) {</span>
<span class="line">        total += arguments[i];</span>
<span class="line">    }</span>
<span class="line">    return total;</span>
<span class="line">}</span>
<span class="line">console.log(sum(1, 2, 3)); // 输出 6</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>箭头函数：没有自己的 arguments 对象，它会捕获外层函数的 arguments（如果存在）。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">const sum = () =&gt; {</span>
<span class="line">    // 尝试访问 arguments 会报错或引用外层作用域的 arguments</span>
<span class="line">    console.log(arguments); // 报错：ReferenceError (如果没有外层函数)</span>
<span class="line">};</span>
<span class="line">sum(1, 2, 3);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>剩余参数语法的差异</li></ol><ul><li>普通函数：可以使用剩余参数语法（...args）来收集所有参数到一个数组中。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function sum(...args) {</span>
<span class="line">  return args.reduce((acc, val) =&gt; acc + val, 0);</span>
<span class="line">}</span>
<span class="line">console.log(sum(1, 2, 3)); // 输出 6</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>箭头函数：同样支持剩余参数语法，且是推荐的动态参数处理方式。 ...args 可以获取所有参数，args 是一个真正的数组，可以直接使用数组的方法。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">const sum = (...args) =&gt; {</span>
<span class="line">  return args.reduce((acc, val) =&gt; acc + val, 0);</span>
<span class="line">};</span>
<span class="line">console.log(sum(1, 2, 3)); // 输出 6</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>上下文（this）绑定的差异</li></ol><ul><li>普通函数：在普通函数中，this 是在调用时动态绑定的，取决于函数的调用方式。arguments 对象与当前函数的上下文（this）绑定。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function MyClass() {</span>
<span class="line">    this.value = 10;</span>
<span class="line">    setTimeout(function() {</span>
<span class="line">        console.log(this.arguments); // 指向 setTimeout 的参数</span>
<span class="line">        console.log(this.value); // 输出 undefined（this 指向全局对象或 undefined）</span>
<span class="line">    }, 100);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>箭头函数：箭头函数的 this 是在定义时绑定的，它不会根据调用上下文改变。没有自己的 this，arguments 会继承外层函数的上下文。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function MyClass() {</span>
<span class="line">  this.value = 10;</span>
<span class="line">  setTimeout(() =&gt; {</span>
<span class="line">    console.log(this.value); // 输出 10（继承 MyClass 的 this）</span>
<span class="line">  }, 100);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2025-07-14T01:07:57.000Z" data-allow-mismatch>2025/7/14 01:07</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 2421447099@qq.com">wangyue</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/guide/browser.html" aria-label="浏览器知识"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">浏览器知识</span></div><!--]--></a><a class="route-link auto-link next" href="/guide/webpack.html" aria-label="Webpack知识"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">Webpack知识</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-rlsOa5gl.js" defer></script>
  </body>
</html>
